\chapter{Basics of Quantum Error Correction}
\label{chap-basics}

\section{The Quantum Channel}

Even when a pure state comes out, it might not be the same state as the one that went in.

From now on, I will only consider the effects of a (possibly non-unitary) matrix acting on a pure state.

\section{A Simple Code}

For the moment, let us consider only channels which cause an error on a
single qubit at a time.  We wish to protect a single logical qubit against
error.  We cannot send it through the channel as is, because the one qubit
that is affected might be the one we want to keep.  Suppose we send through
nine qubits after encoding the logical qubit as follows:
\begin{eqnarray}
	\ket{0} & \rightarrow & \ket{\overline{0}} = (\ket{000} + \ket{111})
	(\ket{000} + \ket{111}) (\ket{000} + \ket{111}) \\
	\ket{1} & \rightarrow & \ket{\overline{1}} = (\ket{000} - \ket{111})
	(\ket{000} - \ket{111}) (\ket{000} - \ket{111}).
\end{eqnarray}
The data is no longer stored in a single qubit, but instead spread out
among nine of them.  Note that even if we know the nine qubits are in one
of these two states, we cannot determine which one without making a
measurement on at least three qubits.  This code is due to
Shor~\cite{shor-9qubit}.

Suppose the channel flips a single qubit, say the first one, switching
$\ket{0}$ and $\ket{1}$.  Then by comparing the first two qubits, we find
they are different, which is not allowed for any valid codeword.  Therefore
we know an error occurred, and furthermore, it flipped either the first or
second qubit.  Note that we do not actually measure the first and second
qubits, since this would destroy the superposition in the codeword; we just
measure the difference between them.

Now we compare the first and third qubits.  Since the first qubit was
flipped, it will disagree with the third; if the second qubit had been
flipped, the first and third would have agreed.  Therefore, we have
narrowed down the error to the first qubit and we can fix it simply by
flipping it back.  To handle possible bit flips on the other blocks of three,
we do the same comparisons inside the other blocks.

However, this is not the only sort of error that could have occurred.  The
channel might have left the identity of the 0 and 1 alone, but altered their
relative phase, introducing, for instance, a relative factor of $-1$ when
the first qubit is $\ket{1}$.  Then the two basis states become
\begin{eqnarray}
	\ket{\overline{0}} & \rightarrow & (\ket{000} - \ket{111}) (\ket{000} +
	\ket{111}) (\ket{000} + \ket{111}) \\
	\ket{\overline{1}} & \rightarrow & (\ket{000} + \ket{111}) (\ket{000} -
	\ket{111}) (\ket{000} - \ket{111}).
\end{eqnarray}
By comparing the sign of the first block of three with the second block of
three, we can see that a sign error has occurred in one of those blocks.
Then by comparing the signs of the first and third blocks of three, we
narrow the sign error down to the first block, and flip the sign back to
what it should be.  Again, we do not want to actually measure the signs,
only whether they agree.  In this case, measuring the signs would give us
information about whether the state is $\ket{\overline{0}}$ or
$\ket{\overline{1}}$, which would destroy any superposition between
them.

This does not exhaust the list of possible one qubit errors.  For instance, we
could have both a bit flip and a sign flip on the same qubit.  However, by
going through both processes described above, we will fix first the bit flip,
then the sign flip (in fact, this code will correct a bit flip and a sign flip
even if they are on different qubits).

The most general one-qubit error that can occur is always be written as the complex linear combination of $X$, $Y$, $Z$, and $I$.
Consider what happens to the code when such an error occurs:
\begin{equation}
	\ket{\psi} = \alpha \ket{\overline{0}} + \beta \ket{\overline{1}}
	\rightarrow a X_{i} \ket{\psi} + b Y_{i} \ket{\psi} + c Z_{i} \ket{\psi} +
	d \ket{\psi}.
\end{equation}

This measurement of which error (or the identity) has occurred, causing the state, originally in a superposition, to collapse to $X_{i} \ket{\psi}$ with probability $|a|^2$, to $Y_{i} \ket{\psi}$ with probability $|b|^2$, to $Z_{i} \ket{\psi}$ with probability $|c|^2$, and to $\ket{\psi}$ with probability $|d|^2$.
In any of the four cases, we have determined which error occurred and we can fix it.

\section{Properties of Any Quantum Code}
\label{sec-general-prop}

Now let us consider properties of more general codes.  A code to encode
$k$ qubits in $n$ qubits will have $2^k$ basis codewords corresponding to
the basis of the original states.  Any linear combination of these basis
codewords is also a valid codeword, corresponding to the same linear
combination of the unencoded basis states.  The space $T$ of valid
codewords (the {\em coding space}) is therefore a Hilbert space in its own
right, a subspace of the full $2^n$-dimensional Hilbert space.  As with
Shor's nine-qubit code, if we can correct errors $E$ and $F$, we can correct
$aE + bF$, so we only need to consider whether the code can correct a basis of
errors.  One convenient basis to use is the set of tensor products of $X$,
$Y$, $Z$, and $I$.  The {\em weight} of an operator of this form is the
number of qubits on which it differs from the identity.  The set of all these
tensor products with a possible overall factor of $-1$ or $\pm i$ forms a
group $\G$ under multiplication.  $\G$ will play a major role in the
stabilizer formalism.  Sometimes I will write it $\G_n$ to distinguish the
groups for different numbers of qubits.  $\G_1$ is just the quaternionic
group; $\G_n$ is the direct product of $n$ copies of the quaternions
modulo all but a global phase factor.

In order for the code to correct two errors $E_a$ and $E_b$, we must
always be able to distinguish error $E_a$ acting on one basis codeword
$\ket{\psi_i}$ from error $E_b$ acting on a different basis codeword
$\ket{\psi_j}$.  We can only be sure of doing this if $E_a \ket{\psi_1}$ is
orthogonal to $E_b \ket{\psi_2}$; otherwise there is some chance of
confusing them.  Thus,
\begin{equation}
	\bra{\psi_i} E_a^\dagger E_b \ket{\psi_j} = 0
	\label{eq-cond-orthogonal}
\end{equation}
when $i \neq j$ for correctable errors $E_a$ and $E_b$.  Note that we
normally include the identity in the set of possible ``errors,'' since we do
not want to confuse an error on one qubit with nothing happening to another.
If we have a channel in which we are certain {\em some} error occurred,
we do not need to include the identity as a possible error.  In any case,
the set of correctable errors is unlikely to be a group --- it does not
even need to be closed under multiplication.

However, (\ref{eq-cond-orthogonal}) is insufficient to guarantee a code will
work as a quantum error-correcting code.  When we make a measurement to find
out about the error, we must learn nothing about the actual state of the code
within the coding space.  If we did learn something, we would be disturbing
superpositions of the basis states, so while we might correct the basis
states, we would not be correcting an arbitrary valid codeword.  We learn
information about the error by measuring $\bra{\psi_i} E_a^\dagger E_b
\ket{\psi_i}$ for all possible errors $E_a$ and $E_b$.  This quantity must
therefore be the same for all the basis codewords:
\begin{equation}
	\bra{\psi_i} E_a^\dagger E_b \ket{\psi_i} = \bra{\psi_j} E_a^\dagger E_b
	\ket{\psi_j}.
	\label{eq-cond-structure}
\end{equation}
We can combine equations (\ref{eq-cond-orthogonal}) and
(\ref{eq-cond-structure}) into a single equation:
\begin{equation}
	\bra{\psi_i} E_a^\dagger E_b \ket{\psi_j} = C_{ab} \delta_{ij},
	\label{eq-condition}
\end{equation}
where $\ket{\psi_i}$ and $\ket{\psi_j}$ run over all possible basis
codewords, $E_a$ and $E_b$ run over all possible errors, and $C_{ab}$ is
independent of $i$ and $j$.  This condition was found by Knill and
Laflamme~\cite{knill-laflamme-theory} and Bennett {\it et
al.}~\cite{bennett-tome}.

The above argument shows that (\ref{eq-condition}) is a necessary
condition for the code to correct the errors $\{E_a\}$.  It is also a
sufficient condition:  The matrix $C_{ab}$ is Hermitian, so it can be
diagonalized.  If we do this and rescale the errors $\{E_a\}$ appropriately, we
get a new basis $\{F_a\}$ for the space of possible errors, with either
\begin{equation}
	\bra{\psi_i} F_a^\dagger F_b \ket{\psi_j} = \delta_{ab} \delta_{ij}
\end{equation}
or
\begin{equation}
	\bra{\psi_i} F_a^\dagger F_b \ket{\psi_j} = 0,
\end{equation}
depending on $a$.  Note that this basis will not necessarily contain
operators that are tensor products of one-qubit operators.  Errors of the
second type actually annihilate any codeword, so the probability of one
occuring is strictly zero and we need not consider them.  The other errors
always produce orthogonal states, so we can make some measurement that
will tell us exactly which error occurred, at which point it is a simple
matter to correct it.  Therefore, a code satisfies equation
(\ref{eq-condition}) for all $E_a$ and $E_b$ in some set ${\cal E}$ iff the
code can correct all errors in ${\cal E}$.

Another minor basis change allows us to find a basis where any two errors
acting on a given codeword either produce orthogonal states or exactly the
same state.  The errors $F_a$  that annihilate codewords correspond to two
errors that act the same way on codewords.  For instance, in Shor's
nine-qubit code, $\Zs{1}$ and $\Zs{2}$ act the same way on the code, so $\Zs{1}
- \Zs{2}$ will annihilate codewords.  This phenomenon will occur iff $C_{ab}$
does not have maximum rank.  A code for which $C_{ab}$ is singular is
called a {\em degenerate} code, while a code for which it is not is {\em
nondegenerate}.  Shor's nine-qubit code is degenerate; we will see many
examples of nondegenerate codes later.  Note that whether a code is
degenerate or not depends on the set of errors it is intended to correct.
For instance, a two-error-correcting degenerate code might be
nondegenerate when considered as a one-error-correcting code.

In equation~(\ref{eq-condition}), $E = E_a^\dagger E_b$ is still in the group
$\G$ when $E_a$ and $E_b$ are in $\G$.  The weight of the smallest $E$ in
$\G$ for which (\ref{eq-condition}) does {\em not} hold is called the {\em
distance} of the code.  A quantum code to correct up to $t$ errors must
have distance at least $2t+1$.  Every code has distance at least one.  A
distance $d$ code encoding $k$ qubits in $n$ qubits is described as an
$[n, k, d]$ code.  Note that a quantum $[n,k,d]$ code is often written
in the literature as $[[n,k,d]]$ to distinguish it from a classical
$[n,k,d]$ code.  I have chosen the notation $[n,k,d]$ to emphasize the
similarities with the classical theory; when I need to distinguish, I
will do so using the words ``quantum'' and ``classical.''

We can also consider variations of the usual error-correction problem.
For instance, suppose we only want to detect if an error has occurred, not
to correct it.  This could, for instance, be used to prevent errors using the
quantum Zeno effect~\cite{vaidman}.  In this case, we do not need to
distinguish error $E_a$ from $E_b$, only from the identity.  We can use the
same argument to find (\ref{eq-condition}), only now $E_b = I$ always.
This means a code to detect $s$ errors must have distance at least $s+1$.
Another variation is when we know in which qubit(s) an error has
occurred, as in the quantum erasure channel~\cite{grassl}.  In this case, we
only need distinguish $E_a$ from those $E_b$ affecting the same qubits.
This means that $E_a^\dagger E_b$ has the same weight as $E_a$, and to correct
$r$ such located errors, we need a code of distance at least $r+1$.  We can
also imagine combining all of these tasks.  A code to correct $t$ arbitrary
errors, $r$ additional located errors, and detect a further $s$ errors must
have distance at least $r + s + 2t + 1$.

\section{Error Models}

In this thesis, I will mostly assume that errors occur independently on
different qubits, and that when an error occurs on a qubit, it is equally
likely to be a $X$, $Y$, or $Z$ error.  If the probability $\epsilon$ of
error per qubit is fairly small, it is often useful to simply ignore the
possibility of more than $t$ errors, since this only occurs with probability
$O(\epsilon^{t+1})$.  Thus, I will typically deal with codes that correct up
to $t$ arbitrary errors.  Such a code will handle any error on up to $t$ qubits
that leaves the data somewhere in the normal computational space (although
moving it outside of the space of valid codewords).

In some systems, there will be errors that move the system outside of the
computational space.  For instance, if the data is stored as the ground or
metastable excited state of an ion, the electron might instead end up in a
different excited state.  If the data is stored in the polarization of a
photon, the photon might escape.  In both of these cases, the normal error
correction networks will not function properly, since they assume that the
qubit is either in the state $\ket{0}$ or $\ket{1}$.  However, by performing
some measurement that distinguishes between the computational Hilbert space
and other possible states, we can determine not only that this sort of
	{\em leakage error} has occurred, but also on which qubit it has occurred.
Then we can cool the atom to the ground state or introduce a new photon with
random polarization, and the error becomes a located error, which was
discussed at the end of the previous section.  One possible network of gates
to detect a leakage error is given in figure~\ref{fig-leakage} (see appendix
\ref{app-gates} for a description of the symbols used in this and later
figures).
\begin{figure}
	\centering
	\begin{picture}(120,60)

		\put(0,34){\makebox(20,12){$\ket{\psi}$}}
		\put(0,14){\makebox(20,12){$\ket{0}$}}

		\put(20,20){\line(1,0){100}}
		\put(20,40){\line(1,0){100}}

		\put(40,40){\circle*{4}}
		\put(40,40){\line(0,-1){24}}
		\put(40,20){\circle{8}}

		\put(60,40){\circle{8}}
		\put(60,36){\line(0,1){8}}

		\put(80,40){\circle*{4}}
		\put(80,40){\line(0,-1){24}}
		\put(80,20){\circle{8}}

		\put(100,40){\circle{8}}
		\put(100,36){\line(0,1){8}}

	\end{picture}
	\caption{Network to detect leakage errors.}
	\label{fig-leakage}
\end{figure}
This network asssumes that states outside the normal computational space do
not interact at all with other qubits.  If the data state $\ket{\psi}$ is
either $\ket{0}$ or $\ket{1}$, the ancilla qubit will flip and become $\ket{1}$.
If the data state is neither $\ket{0}$ nor $\ket{1}$, the ancilla will remain
$\ket{0}$, thus signalling a leakage error on this data qubit.

Another possible difficulty arises when correlated errors on multiple qubits
can occur.  While this can in principle be a severe problem, it can be handled
without a change in formalism as long as the chance of a correlated error drops
rapidly enough with the size of the blocks of errors.  Since a $t$-qubit
error will occur with probability $O(\epsilon^t)$ when the probability of
uncorrelated single-qubit errors is $\epsilon$, as long as the probability
of a $t$-qubit correlated error is $O(\epsilon^t)$, the correlated errors
cause no additional problems.

In real systems, the assumption that errors are equally likely to be $X$,
$Y$, and $Z$ errors is a poor one.  In practice, some linear combinations
of $X$, $Y$, and $Z$ are going to be more likely than others.  For instance,
when the qubits are ground or excited states of an ion, a likely source of
errors is spontaneous emission.  After some amount of time, the excited
state will either decay to the ground state, producing the error $X + iY$
with probability $\epsilon$, or it will not, which changes the relative
amplitudes of $\ket{0}$ and $\ket{1}$, resulting in the error $I - Z$ with
probability $O (\epsilon^2)$.  A channel that performs this sort of time
evolution is known as an {\em amplitude damping} channel.  Since the only
$O(1)$ effect of time evolution is the identity, this sort of error can be
protected against to lowest order by a code to correct an arbitrary single
error.  However, codes that take account of the restricted possibilities
for errors can be more efficient than codes that must correct a general
error~\cite{leung}, and understanding the physically likely sources of
error will certainly be an important part of engineering quantum computers.